# Snapshot report for `src/models/spreadsheet/engine/progressive_eval.async.spec.js`

The actual snapshot is saved in `progressive_eval.async.spec.js.snap`.

Generated by [AVA](https://avajs.dev).

## async MemberExpression with a ComputedProperty

> Snapshot 1

    'this.nodes[0].reactiveFlow(this.nodes[0].transpile(this.nodes[1].reactiveFlow(this.nodes[1].transpile(this.nodes[2].reactiveFlow(this.external("delayed")(1, this.nodes[5].evaluator({}))))),"x" + "y"))'

## MemberExpression with an async ComputedProperty

> Snapshot 1

    'this.nodes[0].reactiveFlow(this.nodes[0].transpile({xy:this.external("xy")},this.nodes[3].reactiveFlow(this.nodes[3].transpile(this.nodes[4].reactiveFlow(this.external("delayed")(1, this.nodes[7].evaluator({})))))))'

## async CallExpression

> Snapshot 1

    'this.nodes[0].reactiveFlow(this.nodes[0].transpile(this.nodes[1].transpile(Math),this.nodes[3].reactiveFlow(this.nodes[3].transpile(this.nodes[4].reactiveFlow(this.external("delayed")(1, this.nodes[7].evaluator({})))))))'

## async CallExpression with this argument

> Snapshot 1

    'this.nodes[0].reactiveFlow(this.nodes[0].transpile(this.nodes[1].transpile(this.external("range")(0, 5)),this.nodes[6].reactiveFlow(this.nodes[6].transpile(this.nodes[7].reactiveFlow(this.external("delayed")(1, this.nodes[10].evaluator({})))))))'

## async CallExpression with async callee and spread arguments

> Snapshot 1

    'this.nodes[0].reactiveFlow(this.nodes[0].transpile(this.nodes[1].reactiveFlow(this.nodes[1].transpile(this.nodes[2].reactiveFlow(this.external("delayed")(1, this.nodes[5].evaluator({}))))),this.external("range")(1, 3),this.external("range")(4, 6)))'

## async CallExpression with async callee and this argument

> Snapshot 1

    'this.nodes[0].reactiveFlow(this.nodes[0].transpile(this.nodes[1].reactiveFlow(this.nodes[1].transpile(this.nodes[2].reactiveFlow(this.nodes[2].transpile(this.nodes[3].reactiveFlow(this.external("delayed")(1, this.nodes[6].evaluator({}))))))),2))'

## async CallExpression with async callee and a chain of properties / calls

> Snapshot 1

    'this.nodes[0].reactiveFlow(this.nodes[0].transpile(this.nodes[1].reactiveFlow(this.nodes[1].transpile(this.nodes[2].reactiveFlow(this.nodes[2].transpile(this.nodes[3].reactiveFlow(this.external("delayed")(1, this.nodes[6].evaluator({}))))),1,1))))'

## o[p](args) with o, p sync but o[p] async resolving to a function

> Snapshot 1

    'this.nodes[0].reactiveFlow(this.nodes[0].transpile(this.nodes[1].reactiveFlow(this.nodes[1].transpile(({ f: this.nodes[3].reactiveFlow(this.nodes[3].transpile(this.nodes[4].reactiveFlow(this.external("delayed")(1, this.nodes[7].evaluator({}))))) }))),8))'

## o[p](args) with o, p sync but o[p] async resolving to a non-function

> Snapshot 1

    'this.nodes[0].reactiveFlow(this.nodes[0].transpile(this.nodes[1].reactiveFlow(({ f: this.nodes[3].reactiveFlow(this.nodes[3].transpile(this.nodes[4].reactiveFlow(this.external("delayed")(1, this.nodes[7].evaluator({}))))) }).f),0))'

## NewExpression with async constructor

> Snapshot 1

    'this.nodes[0].reactiveFlow(this.nodes[0].transpile((this.nodes[1].reactiveFlow(this.nodes[1].transpile(this.nodes[2].reactiveFlow(this.nodes[2].transpile(this.nodes[3].reactiveFlow(this.external("delayed")),this.nodes[4].reactiveFlow(1),this.nodes[5].evaluator({})))))),this.nodes[7].reactiveFlow(3)))'

> Snapshot 2

    'this.nodes[0].reactiveFlow(this.nodes[0].transpile((this.nodes[1].reactiveFlow(this.nodes[1].transpile(this.nodes[2].reactiveFlow(this.external("delayed")(1, this.nodes[5].evaluator({})))))),3))'

## async sum

> Snapshot 1

    'this.nodes[0].reactiveFlow(this.nodes[0].transpile(this.external("sum"),this.nodes[2].reactiveFlow(this.external("delayed")(1, [ this.nodes[6].reactiveFlow(this.external("delayed")(1, 55)), this.nodes[10].reactiveFlow(this.external("delayed")(1, 33)) ]))))'

## race

> Snapshot 1

    'this.nodes[0].reactiveFlow(this.nodes[0].transpile(this.nodes[1].evaluator({}),this.external("race")([this.nodes[9].reactiveFlow(this.nodes[9].transpile(this.nodes[10].reactiveFlow(this.external("delayed")(10, this.nodes[13].evaluator({}))))), this.nodes[16].reactiveFlow(this.nodes[16].transpile(this.nodes[17].reactiveFlow(this.external("delayed")(1, this.nodes[20].evaluator({})))))])))'

## that everything else (including .then callbacks) is still transpiled

> Snapshot 1

    'this.nodes[0].reactiveFlow(this.nodes[0].transpile(this.nodes[1].evaluator({}),Promise.resolve(42)))'
